#!/usr/bin/python

import struct #Strips/Parses through data/binary, specifically, network traffic in this case.
import socket
import os
import binascii

def analyze_udp_header(data):
	
	udp_hdr  = struct.unpack("!4H", data[:8])
	src_port = udp_hdr[0]
	dst_port = udp_hdr[1]
	length   = udp_hdr[2]
	checksum = udp_hdr[3]
	data     = data[8:]
	
	return data 
	
def analyze_tcp_header(data):
	
	tcp_hdr     = struct.unpack("!2H2I4H", data[:20])
	src_port    = tcp_hdr[0]
	dst_port    = tcp_hdr[1]
	seq_num     = tcp_hdr[2]
	ack_num     = tcp_hdr[3]
	data_offset = tcp_hdr[4] >> 12
	reserved    = (tcp_hdr[4] >> 6) & 0x03ff #MUST BE ZERO
	flags       = tcp_hdr[4] & 0x003f
	urg         = flags & 0x0020
	ack         = flags & 0x0010
	psh         = flags & 0x0008
	rst         = flags & 0x0004
	syn         = flags & 0x0002
	fin         = flags & 0x0001
	window      = tcp_hdr[5]
	checksum    = tcp_hdr[6]
	urg_pointer = tcp_hdr[7]
	
	data = data[20:]
	
	return data
	
def analyze_ip_header(data):
	ip_hdr = struct.unpack("!6H4s4s", data[:20])
	ver    = ip_hdr[0] >> 12 #ROR 12 bits
	IHL    = (ip_hdr[0] >> 8) & 0x0f #00001111 Internet Header Length
	tos    = ip_hdr[0] & 0x00ff #0000000011111111 Type of Service
	tl     = ip_hdr[1] #Total Length
	ip_id  = ip_hdr[2]
	flags  = ip_hdr[3] >> 13 #only the first 3 bits
	fos    = ip_hdr[3] & 0x1fff #frag offset
	ip_ttl = ip_hdr[4] >> 8
	ip_pro = ip_hdr[4] & 0x00ff #Ip protocol
	chk_sum = ip_hdr[5] 
	src_addr = socket.inet_ntoa(ip_hdr[6])
	dst_addr = socket.inet_ntoa(ip_hdr[7])
	
	if ip_pro == 6: #TCP magic number
		next_proto = "TCP"
	if ip_pro == 17: #UDP Magic Number
		next_proto = "UDP"
		
	
	data = data[20:]
	
	
	print "==============="
	print "   IP Header   "
	print "==============="
	print ''
	print "Version: %s"                % ver
	print "Internet Header Length: %s" % IHL
	print "Type of Service: %s"        % tos
	print "Total Length: %s"           % tl
	print "IP Id: %s"                  % ip_id
	print "Flags: %s"                  % flags
	print "Frag Offset: %s"            % fos
	print "IP TTL: %s"                 % ip_ttl
	print "IP Protocol: %s"            % ip_pro
	print "Checksum: %s"               % chk_sum
	print "Source Address: %s"         % src_addr
	print "Destination Address: %s"    %dst_addr
	print ''
	

	return data, next_proto
	
def analyze_ether_header(data):
	
	ip_bool = False #IPv4 flag
	
	eth_hdr  = struct.unpack("!6s6sH", data[:14]) #IPv4 = 0x0800, this return a tuple of the following data:
	dest_mac = binascii.hexlify(eth_hdr[0]) #Destination Address
	src_mac  = binascii.hexlify(eth_hdr[1]) #Source Address
	proto    = eth_hdr[2] >> 8 #Next Protocol
	
	print "====================="
	print "   Ethernet Header   "
	print "====================="
	print ''
	print "Destination Mac Address: %s:%s:%s:%s:%s:%s" %  (dest_mac[0:2],dest_mac[2:4],dest_mac[4:6],dest_mac[6:8],dest_mac[8:10],dest_mac[10:12])
	print "Source Mac Address: %s:%s:%s:%s:%s:%s"      %  (src_mac[0:2],src_mac[2:4],src_mac[4:6],src_mac[6:8],src_mac[8:10],src_mac[10:12])
	print "Protocol: %s"                               % hex(proto)
	print ''
	
	if proto == 0x0800: #IPv4
		ip_bool = True
	
	data = data[14:]
	
	return data, ip_bool


def main():
	
	sniffer_socket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
	recv_data      = sniffer_socket.recv(2048)
	analyze_ether_header(recv_data)
	
	os.system('clear')
	
	data, ip_bool = analyze_ether_header(recv_data)
	
	if ip_bool:
		data, next_proto = analyze_ip_header(data)
	else:
		return
	
	if next_proto == "TCP":
		analyze_tcp_header(data)
	elif next_proto == "UDP":
		data = analyza_udp_header(data)

while True:	
	main()
	
