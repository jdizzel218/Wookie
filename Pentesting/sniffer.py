#!/usr/bin/python

import struct #Strips/Parses through data/binary, specifically, network traffic in this case.
import socket
import os
import binascii


'''
TODO

- Group packets by src and dest. 
- Handle arguments to filter out / look for specific traffic
- Generate Alerts based on traffic,src,dest, etc.
- Specify which interface you want to sniff on


'''

def analyze_udp_header(data):
	
	udp_hdr  = struct.unpack("!4H", data[:8])
	src_port = udp_hdr[0]
	dst_port = udp_hdr[1]
	length   = udp_hdr[2]
	checksum = udp_hdr[3]
	
	print ''
	print "================"
	print "   UDP Header   "
	print "================"
	print "Source Port: %s "     % src_port
	print "Destination Port: %s" % dst_port
	print "Length: %s"           % length
	print "Checksum: %s"         % checksum
	
	
	data = data[8:]
	
	return data 
	
def analyze_tcp_header(data):
	
	tcp_hdr     = struct.unpack("!2H2I4H", data[:20]) #Unpack/Parse TCP Header information
	
	src_port    = tcp_hdr[0]
	dst_port    = tcp_hdr[1]
	seq_num     = tcp_hdr[2]
	ack_num     = tcp_hdr[3]
	data_offset = tcp_hdr[4] >> 12
	reserved    = (tcp_hdr[4] >> 6) & 0x03ff #MUST BE ZERO
	flags       = tcp_hdr[4] & 0x003f
	window      = tcp_hdr[5]
	checksum    = tcp_hdr[6]
	urg_pointer = tcp_hdr[7]
	
	#TCP Flags
	urg         = bool(flags & 0x0020)
	ack         = bool(flags & 0x0010)
	psh         = bool(flags & 0x0008)
	rst         = bool(flags & 0x0004)
	syn         = bool(flags & 0x0002)
	fin         = bool(flags & 0x0001)
	
	print "================"
	print "   TCP Header   "
	print "================"
	print "Source Port: %s"            % src_port
	print "Destination Port: %s"       % dst_port
	print "Sequence Number: %s"        % seq_num
	print "Acknowledgement Number: %s" % ack_num
	print "Data Offset: %s"            % data_offset
	print "Flags: %s"                  % flags
	print "Window: %s"                 % window 
	print "Checksum: %s"               % checksum
	print "Urgent Point: %s"           % urg_pointer
	
	print "FLAGS: "
	print "Urg: %s" % urg
	print "Ack: %s" % ack
	print "Psh: %s" % psh
	print "Rst: %s" % rst
	print "Syn: %s" % syn
	print "Fin: %s" % fin
	
	data = data[20:] 
	
	return data
	
def analyze_ip_header(data):
	
	ip_hdr    = struct.unpack("!6H4s4s", data[:20])
	ver       = ip_hdr[0] >> 12         #ROR 12 bits
	ihl       = (ip_hdr[0] >> 8) & 0x0f #00001111 Internet Header Length
	tos       = ip_hdr[0] & 0x00ff      #0000000011111111 Type of Service
	tl        = ip_hdr[1]               #Total Length
	ip_id     = ip_hdr[2]
	flags     = ip_hdr[3] >> 13         #only the first 3 bits
	fos       = ip_hdr[3] & 0x1fff      #frag offset
	ip_ttl    = ip_hdr[4] >> 8
	ip_pro    = ip_hdr[4] & 0x00ff      #Ip protocol
	chk_sum   = ip_hdr[5] 
	src_addr  = socket.inet_ntoa(ip_hdr[6])
	dst_addr  = socket.inet_ntoa(ip_hdr[7])
	no_frag   = flags >> 1
	more_frag = flags & 0x1
	
	if ver == 0: #This handles the printout of version to make it appear nicer.
		ver = ''
	elif ver == 4:
		ver = "IPv%s" % ver
	elif ver == 6:
		ver = "IPv%s" % ver
	else:
		ver = ver
	
	
	print "==============="
	print "   IP Header   "
	print "==============="
	print "Version: %s"                % ver
	print "Internet Header Length: %s" % ihl
	print "Type of Service: %s"        % tos
	print "Total Length: %s"           % tl
	print "IP Id: %s"                  % ip_id
	print "Flags: %s"                  % flags
	print "Frag Offset: %s"            % fos
	print "IP TTL: %s"                 % ip_ttl
	print "IP Protocol: %s"            % ip_pro
	print "Checksum: %s"               % chk_sum
	print "Source Address: %s"         % src_addr
	print "Destination Address: %s"    %dst_addr
	
	
	
	if ip_pro == 6:         #TCP magic number
		next_proto = "TCP"
	elif ip_pro == 17:        #UDP Magic Number
		next_proto = "UDP"
	else:
		next_proto = "OTHER"
		
		
	data = data[20:]

	return data, next_proto
	
def analyze_ether_header(data):
	
	ip_bool = False #IPv4 flag
	
	eth_hdr  = struct.unpack("!6s6sH", data[:14]) #IPv4 = 0x0800, this return a tuple of the following data:
	dest_mac = binascii.hexlify(eth_hdr[0]) #Destination Address
	src_mac  = binascii.hexlify(eth_hdr[1]) #Source Address
	proto    = eth_hdr[2] >> 8 #Next Protocol
	
	
	print "====================="
	print "   Ethernet Header   "
	print "====================="
	print "Destination Mac Address: %s:%s:%s:%s:%s:%s" %  (dest_mac[0:2],dest_mac[2:4],dest_mac[4:6],dest_mac[6:8],dest_mac[8:10],dest_mac[10:12])
	print "Source Mac Address: %s:%s:%s:%s:%s:%s"      %  (src_mac[0:2],src_mac[2:4],src_mac[4:6],src_mac[6:8],src_mac[8:10],src_mac[10:12])
	print "Protocol: %s"                               %  hex(proto)
	print ''
	
	if proto == 0x08: #IPv4
		ip_bool = True
	
	data = data[14:]
	
	return data, ip_bool


def main():
	
	sniffer_socket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x0003)) #Create Socket object
	recv_data      = sniffer_socket.recv(2048) #Sniff packets on socket object.
	analyze_ether_header(recv_data) #Call analyze_ether_header on packets coming from socket object.
	
	os.system('clear') 
	
	data, ip_bool = analyze_ether_header(recv_data)
		
	if ip_bool == True:
		data, next_proto = analyze_ip_header(data) 
	else:
		return #next_proto is only created if we get a ip header, so if we don't we just return to deal with errors.
		
	if next_proto == "TCP":
		analyze_tcp_header(data)
	elif next_proto == "UDP":
		data = analyze_udp_header(data)
	else:
		return #next_proto is only created if we get a ip header(TCP/UDP), so if we don't or we get a different protocol, we just return to deal with errors.
		

while True: #this is bad programming. You should never do this.
	main()
	
